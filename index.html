<script>
const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRV7v_0mQWcqJI9ExD7lphRQDaHnyv65Tp_i2uDiBJOcxAJ5l6jXV1-WFFBKSU9YZErgLDkGB6nYmug/pub?output=csv';

const TRAINING_RULES = {
  "Fire Prevention and Extinguishers":         "All Required",
  "Workplace Violence Prevention":             "All Required",
  "Fall Protection":                           "Field Required",
  "Heat Illness Prevention (Indoor)":          "Field Required",
  "Heat Illness Prevention (Outdoor)":         "Field Required",
  "Personal Protective Equipment":             "Field Required",
  "Silica Awareness Training":                 "Field Required",
  "Wildfire Protection":                       "Field Required",
  "First Aid/CPR/AED":                         "Foreman",
  "Intro to First Aid":                        "Foreman",
  "OSHA 30 Certificate":                       "Optional",
  "Certified Rigger and Signaler":             "Job Dependent",
  "SpecialtyConfined Space":                   "Job Dependent",
  "Confined Space":                            "Job Dependent",
  "Forklift Training":                         "Job Dependent",
  "Mobile Elevated Work Platform":             "Job Dependent",
  "NCCO Crane Operations":                     "Job Dependent",
  "Part 46 New Miner":                         "Job Dependent",
  "Part 46 Refresher":                         "Job Dependent",
  "Respiratory Fit Testing":                   "Job Dependent",
  "Respiratory Medical Questionnare":          "Job Dependent",
  "Silica Dust Exposure":                      "Job Dependent"
};

function isRequiredForRole(topic, role) {
  const rule = TRAINING_RULES[topic];
  if (!rule) return false;
  const r = (role || '').trim().toLowerCase();
  if (rule === "All Required") return true;
  if (rule === "Field Required") return r === "field" || r === "foreman";
  if (rule === "Foreman") return r === "foreman";
  if (rule === "Office") return r === "office";
  return false;
}

let records = [], topicMap = {}, employeeMap = {}, allOverdue = [];

async function loadData() {
  document.getElementById('status').innerHTML = 'Fetching data...';
  try {
    const resp = await fetch(SHEET_URL + '&_=' + Date.now());
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    const parsed = Papa.parse(text, {
      header: true,
      skipEmptyLines: true,
      transformHeader: h => h.trim().replace(/^"|"$/g, ''),
      transform: v => v.trim().replace(/^"|"$/g, '')
    });
    records = parsed.data.filter(r => r['Employee Name'] && r['Topic']);
    document.getElementById('status').innerHTML = `Loaded ${records.length} records`;
    updateLastUpdated();
    return records;
  } catch (err) {
    document.getElementById('status').innerHTML = `<span class="text-danger">Error: ${err.message}</span>`;
    return [];
  }
}

function updateLastUpdated() {
  const now = new Date();
  document.getElementById('lastUpdated').textContent = 
    `Last loaded: ${now.toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' })}`;
}

function parseTextDate(dateStr) {
  if (!dateStr) return 'N/A';
  const months = {Jan:0,Feb:1,Mar:2,Apr:3,May:4,Jun:5,Jul:6,Aug:7,Sep:8,Oct:9,Nov:10,Dec:11};
  const match = dateStr.match(/(\w{3})\s+(\d{1,2}),\s+(\d{4})/);
  if (match) {
    const [_, m, d, y] = match;
    return new Date(y, months[m], d).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
  }
  const parts = dateStr.split('/');
  if (parts.length === 3) {
    const m = parseInt(parts[0],10)-1, d = parseInt(parts[1],10), y = parseInt(parts[2],10);
    if (y > 1900 && !isNaN(m) && !isNaN(d)) return new Date(y, m, d).toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
  }
  return dateStr || 'N/A';
}

function normalizeName(name) {
  return name?.replace(/Perira/gi, 'Pereira')
    .replace(/Silviera/gi, 'Silveira')
    .replace(/[^\w\s]/g, '')
    .trim()
    .toLowerCase()
    .replace(/\s+/g, ' ') || '';
}

function badge(r) {
  const s = r?.['Status'] || '';
  const daysStr = r?.['Days Remaining'] || '';
  const days = parseInt(daysStr, 10);
  let cls = 'bg-secondary', txt = s || '—';
  if (s === 'Completed') { cls = 'badge-comp'; txt = 'Completed'; }
  else if (s === 'Not Due') { cls = 'badge-due'; txt = 'Not Due' + (daysStr ? ` (${daysStr}d)` : ''); }
  else if (s === 'Overdue') { cls = 'badge-over'; txt = 'Overdue' + (daysStr ? ` (${daysStr}d)` : ''); }
  else if (s === 'Due Soon') { cls = 'badge-expiring'; txt = 'Due Soon' + (daysStr ? ` (${daysStr}d)` : ''); }
  return `<span class="badge ${cls}">${txt}</span>`;
}

function daysLeftStyle(daysStr) {
  if (!daysStr || daysStr === 'N/A') return '';
  const days = parseInt(daysStr, 10);
  if (isNaN(days)) return '';
  if (days <= 0) return 'text-danger fw-bold';
  if (days <= 30) return 'text-warning fw-bold';
  return 'text-success';
}

async function buildData() {
  records = await loadData();
  if (!records.length) return;

  topicMap = {}; 
  employeeMap = {}; 
  allOverdue = [];
  let overdueCount = 0, overdueEmps = new Set();
  const uniqueRoles = new Set();

  records.forEach(r => {
    let topic = r['Topic']?.trim();
    if (topic === "Fall Protection Awareness") topic = "Fall Protection";
    if (topic === "SpecialtyConfined Space") topic = "Confined Space";

    const origName = r['Employee Name']?.trim();
    const normName = normalizeName(origName);
    const role = (r['Role'] || '').trim();

    if (role) uniqueRoles.add(role);

    if (!normName || !topic) return;

    if (!employeeMap[normName]) employeeMap[normName] = { original: origName, role, records: {} };
    employeeMap[normName].records[topic] = r;

    if (!topicMap[topic]) topicMap[topic] = [];
    topicMap[topic].push({ ...r, 'Employee Name': origName });

    if (['Overdue', 'Due Soon'].includes(r['Status'])) {
      overdueCount++;
      overdueEmps.add(normName);
      allOverdue.push({ employee: origName, topic, ...r });
    }
  });

  // Flag missing required trainings
  Object.values(employeeMap).forEach(emp => {
    Object.keys(TRAINING_RULES).forEach(t => {
      if (isRequiredForRole(t, emp.role) && !emp.records[t]) {
        overdueCount++;
        overdueEmps.add(normalizeName(emp.original));
        allOverdue.push({ employee: emp.original, topic: t, 'Days Remaining': 'N/A', Status: 'No Record' });
      }
    });
  });

  document.getElementById('overdueCount').textContent = overdueCount;
  document.getElementById('overdueEmps').textContent = overdueEmps.size;
  document.getElementById('overdueBanner').classList.toggle('d-none', overdueCount === 0);

  // Populate role filter dynamically
  const roleSelect = document.getElementById('roleFilter');
  const previouslySelectedRole = roleSelect.value;

  roleSelect.innerHTML = '<option value="">— All Roles —</option>';
  [...uniqueRoles].sort().forEach(role => {
    const opt = document.createElement('option');
    opt.value = role.toLowerCase();  // store lowercase for comparison
    opt.textContent = role.charAt(0).toUpperCase() + role.slice(1).toLowerCase();
    roleSelect.appendChild(opt);
  });

  // Restore previous selection (case-insensitive match)
  if (previouslySelectedRole) {
    const lowerPrev = previouslySelectedRole.toLowerCase();
    const matchingOption = Array.from(roleSelect.options).find(opt => opt.value === lowerPrev);
    if (matchingOption) roleSelect.value = matchingOption.value;
  }

  renderTopics(document.getElementById('topicSearch').value.trim());

  populateEmployeeDropdown();
}

function renderTopics(filter = '') {
  const el = document.getElementById('topicList');
  el.innerHTML = '';
  const topics = Object.keys(topicMap).sort();
  topics.forEach(t => {
    if (filter && !t.toLowerCase().includes(filter.toLowerCase())) return;
    const count = topicMap[t].length;
    const item = document.createElement('a');
    item.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
    item.innerHTML = `<span>${t}</span> <span class="badge bg-primary rounded-pill">${count}</span>`;
    item.onclick = () => showTopicDetail(t);
    el.appendChild(item);
  });
}

document.getElementById('topicSearch').addEventListener('input', e => renderTopics(e.target.value.trim()));

document.getElementById('roleFilter').addEventListener('change', populateEmployeeDropdown);

function populateEmployeeDropdown() {
  const sel = document.getElementById('employeeSelect');
  const selectedRole = document.getElementById('roleFilter').value.trim().toLowerCase();

  sel.innerHTML = '<option value="">— Jump to employee —</option>';

  const filteredEmployees = Object.keys(employeeMap)
    .filter(norm => {
      const empRole = (employeeMap[norm].role || '').trim().toLowerCase();
      const match = !selectedRole || empRole === selectedRole;
      // Debug log - open console (F12) to see why someone might be filtered out
      if (employeeMap[norm].original === "Will Tuttle" || employeeMap[norm].original.includes("Tuttle")) {
        console.log(`Will Tuttle check → empRole: "${empRole}", selected: "${selectedRole}", match: ${match}`);
      }
      return match;
    })
    .sort((a,b) => employeeMap[a].original.localeCompare(employeeMap[b].original));

  filteredEmployees.forEach(norm => {
    const opt = document.createElement('option');
    opt.value = norm;
    opt.textContent = employeeMap[norm].original;
    sel.appendChild(opt);
  });

  sel.onchange = e => { if (e.target.value) showEmployeeDetail(e.target.value); };

  // If no employees match, show message in dropdown
  if (filteredEmployees.length === 0 && selectedRole) {
    const opt = document.createElement('option');
    opt.disabled = true;
    opt.textContent = `(No employees found for ${selectedRole})`;
    sel.appendChild(opt);
  }
}

// ... the rest of your functions (showTopicDetail, showEmployeeDetail, showAllOverdue, exportPDF, openOutlookEmail, dark mode) remain unchanged from your last version ...
</script>
